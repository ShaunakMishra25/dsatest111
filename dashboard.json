{
  "metadata": {
    "totalProblems": 4,
    "lastUpdated": "2025-08-29T10:34:41.187Z",
    "breakdown": {
      "Codechef": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Gfg": {
        "total": 1,
        "Easy": 1,
        "Medium": 0,
        "Hard": 0
      },
      "Leetcode": {
        "total": 3,
        "Easy": 1,
        "Medium": 2,
        "Hard": 0
      },
      "Hackerrank": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "gfg-easy-missing-in-array",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "Missing in Array",
      "language": "java",
      "files": {
        "code": "class Solution {\r\n    int missingNum(int arr[]) {\r\n        int n = arr.length + 1;\r\n    int xor = 0;\r\n    // XOR all numbers from 1 to n\r\n    for (int i = 1; i <= n; i++) {\r\n        xor ^= i;\r\n    }\r\n    // XOR all elements in array\r\n    for (int num : arr) {\r\n        xor ^= num;\r\n    }\r\n    return xor;\r\n    }\r\n}",
        "readme": "Arrays,Searching,Bit_Magic,Data_Structures,Algorithms\n\nMissing in Array\nDifficulty: EasyAccuracy: 29.59%Submissions: 1.5MPoints: 2Average Time: 15m\n\nYou are given an array arr[] of size n - 1 that contains distinct integers in the range from 1 to n (inclusive). This array represents a permutation of the integers from 1 to n with one element missing. Your task is to identify and return the missing element.\n\nExamples:\n\nInput: arr[] = [1, 2, 3, 5]\nOutput: 4\nExplanation: All the numbers from 1 to 5 are present except 4.\n\nInput: arr[] = [8, 2, 4, 5, 3, 7, 1]\nOutput: 6\nExplanation: All the numbers from 1 to 8 are present except 6.\nInput: arr[] = [1]\nOutput: 2\nExplanation: Only 1 is present so the missing element is 2.\n\n\nConstraints:\n1 ≤ arr.size() ≤ 106\n1 ≤ arr[i] ≤ arr.size() + 1\n\nTry more examples\nExpected Complexities\nCompany Tags\nFlipkartMorgan StanleyAccoliteAmazonMicrosoftD-E-ShawOla CabsPayuVisaIntuitAdobeCiscoQualcommTCS\nTopic Tags\nRelated Interview Experiences\nRelated Articles\nReport An Issue\nIf you are facing any issue on this page. Please let us know.",
        "notes": "Missing in Array\n\n          - Summary: The code uses an integer array to store input numbers. It leverages the bitwise XOR operation. First, it XORs all numbers from 1 to n (where n is the expected array length including the missing number). Then, it XORs all the elements present in the input array with the previously calculated XOR value. The final XOR result gives the missing number because XORing a number with itself results in 0, leaving only the missing number.\n\n          - Time Complexity: O(n) because the code iterates through the array of size n once and then iterates from 1 to n once, resulting in a total of 2n iterations. The XOR operation is considered O(1).\n          - Space Complexity: O(1) because the code uses a constant amount of extra space to store variables like n and xor, irrespective of the input array's size."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-29T10:34:41.067Z"
    },
    {
      "id": "leetcode-easy-two-sum",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Two Sum",
      "language": "python",
      "files": {
        "code": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        num_map={}\n        for i,num in enumerate(nums):\n            comp=target-num\n            if comp in num_map:\n                return [num_map[comp],i]\n            num_map[num]=i",
        "readme": "ArrayHashTable\n\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n \nConstraints:\n\n\n\t2 <= nums.length <= 104\n\t-109 <= nums[i] <= 109\n\t-109 <= target <= 109\n\tOnly one valid answer exists.\n\n\n \nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
        "notes": "Two Sum\n\n          - Summary: This algorithm utilizes a hash map (dictionary in Python) to efficiently find two numbers within a list that add up to a target value. It iterates through the input list, calculating the complement needed to reach the target for each number. If the complement is found in the hash map, it means a pair has been identified, and their indices are returned. Otherwise, the current number and its index are added to the hash map for future checks.\n\n          - Time Complexity: O(n) because the algorithm iterates through the input list once.  Hash map lookups are O(1) on average.\n          - Space Complexity: O(n) because in the worst case, the hash map might store all the numbers from the input list."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-29T10:34:41.069Z"
    },
    {
      "id": "leetcode-medium-longest-substring-without-repeating-characters",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Longest Substring Without Repeating Characters",
      "language": "python",
      "files": {
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        \n        maxlen = 0\n        start = 0\n\n        seen = {}\n\n        for i, c in enumerate(s):\n\n            if c in seen and start <= seen[c]:\n                start = seen[c] + 1\n            else:\n                maxlen = max(maxlen, i-start+1)\n\n            seen[c] = i\n\n        return maxlen",
        "readme": "HashTableStringSlidingWindow\n\nGiven a string s, find the length of the longest substring without duplicate characters.\n\n \nExample 1:\n\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n\n\nExample 2:\n\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n\n\nExample 3:\n\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n\n \nConstraints:\n\n\n\t0 <= s.length <= 5 * 104\n\ts consists of English letters, digits, symbols and spaces.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-29T10:34:41.071Z"
    },
    {
      "id": "leetcode-medium-reverse-words-in-a-string",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Reverse Words in a String",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public String reverseWords(String s) {\n        s=s.trim();\n        String[] s1 = s.split(\"\\\\s+\");\n\n      StringBuilder revs = new StringBuilder();\n      for (int i = s1.length - 1; i >= 0; i--) {\n         revs.append(s1[i]);\n         if (i != 0) revs.append(\" \");\n     }     \n     return revs.toString();\n    }\n}",
        "readme": "TwoPointersString\n\nGiven an input string s, reverse the order of the words.\n\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\n\nReturn a string of the words in reverse order concatenated by a single space.\n\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\n\n \nExample 1:\n\nInput: s = \"the sky is blue\"\nOutput: \"blue is sky the\"\n\n\nExample 2:\n\nInput: s = \"  hello world  \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.\n\n\nExample 3:\n\nInput: s = \"a good   example\"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string.\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 104\n\ts contains English letters (upper-case and lower-case), digits, and spaces ' '.\n\tThere is at least one word in s.\n\n\n \nFollow-up: If the string data type is mutable in your language, can you solve it in-place with O(1) extra space?",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-29T10:34:41.072Z"
    }
  ]
}