{
  "metadata": {
    "totalProblems": 2,
    "lastUpdated": "2025-08-28T14:14:45.033Z",
    "breakdown": {
      "Codechef": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Gfg": {
        "total": 1,
        "Easy": 1,
        "Medium": 0,
        "Hard": 0
      },
      "Leetcode": {
        "total": 1,
        "Easy": 1,
        "Medium": 0,
        "Hard": 0
      },
      "Hackerrank": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "gfg-easy-missing-in-array",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "Missing in Array",
      "language": "java",
      "files": {
        "code": "class Solution {\r\n    int missingNum(int arr[]) {\r\n        int n = arr.length + 1;\r\n    int xor = 0;\r\n    // XOR all numbers from 1 to n\r\n    for (int i = 1; i <= n; i++) {\r\n        xor ^= i;\r\n    }\r\n    // XOR all elements in array\r\n    for (int num : arr) {\r\n        xor ^= num;\r\n    }\r\n    return xor;\r\n    }\r\n}",
        "readme": "Arrays,Searching,Bit_Magic,Data_Structures,Algorithms\n\nMissing in Array\nDifficulty: EasyAccuracy: 29.59%Submissions: 1.5MPoints: 2Average Time: 15m\n\nYou are given an array arr[] of size n - 1 that contains distinct integers in the range from 1 to n (inclusive). This array represents a permutation of the integers from 1 to n with one element missing. Your task is to identify and return the missing element.\n\nExamples:\n\nInput: arr[] = [1, 2, 3, 5]\nOutput: 4\nExplanation: All the numbers from 1 to 5 are present except 4.\n\nInput: arr[] = [8, 2, 4, 5, 3, 7, 1]\nOutput: 6\nExplanation: All the numbers from 1 to 8 are present except 6.\nInput: arr[] = [1]\nOutput: 2\nExplanation: Only 1 is present so the missing element is 2.\n\n\nConstraints:\n1 ≤ arr.size() ≤ 106\n1 ≤ arr[i] ≤ arr.size() + 1\n\nTry more examples\nExpected Complexities\nCompany Tags\nFlipkartMorgan StanleyAccoliteAmazonMicrosoftD-E-ShawOla CabsPayuVisaIntuitAdobeCiscoQualcommTCS\nTopic Tags\nRelated Interview Experiences\nRelated Articles\nReport An Issue\nIf you are facing any issue on this page. Please let us know.",
        "notes": "Missing in Array\n\n          - Summary: The code uses an integer array to store input numbers. It leverages the bitwise XOR operation. First, it XORs all numbers from 1 to n (where n is the expected array length including the missing number). Then, it XORs all the elements present in the input array with the previously calculated XOR value. The final XOR result gives the missing number because XORing a number with itself results in 0, leaving only the missing number.\n\n          - Time Complexity: O(n) because the code iterates through the array of size n once and then iterates from 1 to n once, resulting in a total of 2n iterations. The XOR operation is considered O(1).\n          - Space Complexity: O(1) because the code uses a constant amount of extra space to store variables like n and xor, irrespective of the input array's size."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-28T14:14:45.013Z"
    },
    {
      "id": "leetcode-easy-two-sum",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Two Sum",
      "language": "python",
      "files": {
        "code": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        num_map={}\n        for i,num in enumerate(nums):\n            comp=target-num\n            if comp in num_map:\n                return [num_map[comp],i]\n            num_map[num]=i",
        "readme": "ArrayHashTable\n\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n \nConstraints:\n\n\n\t2 <= nums.length <= 104\n\t-109 <= nums[i] <= 109\n\t-109 <= target <= 109\n\tOnly one valid answer exists.\n\n\n \nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
        "notes": "Two Sum\n\n          - Summary: This algorithm utilizes a hash map (dictionary in Python) to efficiently find two numbers within a list that add up to a target value. It iterates through the input list, calculating the complement needed to reach the target for each number. If the complement is found in the hash map, it means a pair has been identified, and their indices are returned. Otherwise, the current number and its index are added to the hash map for future checks.\n\n          - Time Complexity: O(n) because the algorithm iterates through the input list once.  Hash map lookups are O(1) on average.\n          - Space Complexity: O(n) because in the worst case, the hash map might store all the numbers from the input list."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-28T14:14:45.016Z"
    }
  ]
}